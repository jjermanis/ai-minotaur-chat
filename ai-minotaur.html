<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Maze</title>
<style>
body {
    margin: 0;
    background: black;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100vh;
}

#container {
    display: flex;
    gap: 16px;
}
canvas {
    border: 2px solid #444;
}
#statusRow {
    width: 816px;
    position: relative;
    margin-top: 12px;
}

#status {
    color: white;
    font-size: 18px;
    text-align: center;
    height: 24px;
    line-height: 24px;
}

.ui-button {
    position: absolute;
    right: 0;
    top: 0;
    font-size: 14px;
    padding: 6px 12px;
}

#topRow {
    color: #c9c3b5;
    font-family: "Cinzel", serif;
    font-size: 42px;
    letter-spacing: 6px;
    text-align: center;
    margin-bottom: 4px;
    text-shadow: 2px 2px 6px black;
}


</style>
</head>
<body>

<div id="topRow">
    <div id="title">MINOTAUR</div>
</div>
<div id="container">
    <canvas id="view3d" width="400" height="400"></canvas>
    <canvas id="view2d" width="400" height="400"></canvas>
</div>
<div id="statusRow">
    <div id="status"></div>
    <button id="resetBtn" class="ui-button" disabled style="display:none;">Reset Maze</button>
</div>

<script>
let SIZE;
let CELL;
const FOV = Math.PI / 3;
const RAYS = 200;
const DEFAULT_WALL_COLOR = { r:180, g:30, b:30 };
const MAX_LIGHT_DIST = 12;
const SIZE_OPTIONS = [8, 10, 16, 20, 25];
const CELL_OPTIONS = [50, 40, 25, 20, 16];

let levelIndex = 0;

let minotaurVisible = false;
let minotaurActive = false;
let minotaurHasSeenPlayer = false;
let minotaurTimerStarted = false;
let minotaurStartTime = 0;
let minotaurPath = [];
let minotaurLastMoveTime = 0;
const MINOTAUR_MOVE_DELAY = 500; // ms
const minotaurImg = new Image();
minotaurImg.src = "minotaur.png";

SIZE = SIZE_OPTIONS[levelIndex];
CELL = CELL_OPTIONS[levelIndex];

// Core state (allocated once)
const maze = [];
const wallColors = [];
const seen = [];

const player = {
    x: 0,
    y: 0,
    dir: 1,
    escaped: false,
    defeated: false,
};
const minotaur = {
    x: 0,
    y: 0,
};

// Contexts
const ctx3 = view3d.getContext("2d");
const ctx2 = view2d.getContext("2d");
const statusEl = document.getElementById("status");
const resetBtn = document.getElementById("resetBtn");


let selectedVoice = null;

function selectMinotaurVoice() {
    const voices = speechSynthesis.getVoices();

    const preferredVoiceNames = [
        "Google UK English Female",
        "Google español de Estados Unidos",
        "Google français",
    ];

    for (const preferred of preferredVoiceNames) {
        const found = voices.find(v => v.name === preferred);
        if (found) {
            selectedVoice = found;
            return;
        }
    }

    // Fallback if none found
    selectedVoice = voices[0] || null;
}

// DFS maze generation
function dfs(x, y) {
    maze[y][x].visited = true;
    for (let d of [0,1,2,3].sort(()=>Math.random()-0.5)) {
        const nx = x + [0,1,0,-1][d];
        const ny = y + [-1,0,1,0][d];
        if (nx>=0 && ny>=0 && nx<SIZE && ny<SIZE && !maze[ny][nx].visited) {
            maze[y][x].walls[d] = 0;
            maze[ny][nx].walls[(d+2)%4] = 0;
            dfs(nx, ny);
        }
    }
}

/* ============================
   INIT / RESET GAME
   ============================ */
function initGame() {
    selectMinotaurVoice();
    // Build maze + wall colors
    for (let y = 0; y < SIZE; y++) {
        maze[y] = [];
        wallColors[y] = [];
        seen[y] = [];
        for (let x = 0; x < SIZE; x++) {
            maze[y][x] = { visited:false, walls:[1,1,1,1] };
            wallColors[y][x] = [
                { ...DEFAULT_WALL_COLOR },
                { ...DEFAULT_WALL_COLOR },
                { ...DEFAULT_WALL_COLOR },
                { ...DEFAULT_WALL_COLOR }
            ];
            seen[y][x] = false;
        }
    }

    // Generate maze
    dfs(0, 0);

    // Exit walls (lower-right)
    wallColors[SIZE-1][SIZE-1][1] = { r:0, g:180, b:0 };
    wallColors[SIZE-1][SIZE-1][2] = { r:0, g:180, b:0 };

    // Reset player
    player.x = 0;
    player.y = 0;
    player.dir = 1;
    player.escaped = false;
    player.defeated = false;

    // --- Reset Minotaur State ---
    minotaurVisible = false;
    minotaurActive = false;
    minotaurHasSeenPlayer = false;
    minotaurTimerStarted = false;
    minotaurStartTime = 0;

    // Reset position (invisible until triggered)
    minotaur.x = 0;
    minotaur.y = 0;

    // UI reset
    statusEl.textContent = "";
    resetBtn.disabled = true;
    resetBtn.style.display = "none";
}

function advanceLevel() {
    if (levelIndex < SIZE_OPTIONS.length - 1) {
        levelIndex++;
    } else {
        levelIndex = 0;
    }

    sizeIndex = levelIndex;
    SIZE = SIZE_OPTIONS[sizeIndex];
    CELL = CELL_OPTIONS[sizeIndex];

    initGame();
}

function updateMinotaurTimer() {
    if (!minotaurTimerStarted) return;
    if (player.escaped) return;
    if (player.defeated) return;

    const gridSize = SIZE; // assuming square grid
    const elapsedSeconds = (performance.now() - minotaurStartTime) / 1000;

    // Appear at (0,0) first...
    if (!minotaurVisible && elapsedSeconds >= gridSize * 0.3) {
        minotaurSpeak("awake");
        minotaurVisible = true;
        minotaur.x = 0;
        minotaur.y = 0;
    }

    // ... and later become active
    if (!minotaurActive && elapsedSeconds >= gridSize * 0.7) {
        minotaurSpeak("go");
        minotaurActive = true;
    }
}

function computeMinotaurPath() {

    const visited = Array.from({ length: SIZE }, () =>
        Array(SIZE).fill(false)
    );

    const parent = Array.from({ length: SIZE }, () =>
        Array(SIZE).fill(null)
    );

    const queue = [];

    queue.push({ x: minotaur.x, y: minotaur.y });
    visited[minotaur.y][minotaur.x] = true;

    // MUST match DFS wall ordering
    const directions = [
        { dx: 0, dy: -1, wallIndex: 0 }, // top
        { dx: 1, dy: 0,  wallIndex: 1 }, // right
        { dx: 0, dy: 1,  wallIndex: 2 }, // bottom
        { dx: -1, dy: 0, wallIndex: 3 }  // left
    ];

    let found = false;

    while (queue.length > 0) {
        const current = queue.shift();

        if (current.x === player.x && current.y === player.y) {
            found = true;
            break;
        }

        for (const dir of directions) {

            const nx = current.x + dir.dx;
            const ny = current.y + dir.dy;

            if (
                nx >= 0 && nx < SIZE &&
                ny >= 0 && ny < SIZE &&
                !visited[ny][nx] &&
                maze[current.y][current.x].walls[dir.wallIndex] === 0
            ) {
                visited[ny][nx] = true;
                parent[ny][nx] = current;
                queue.push({ x: nx, y: ny });
            }
        }
    }

    if (!found) return [];

    const path = [];
    let step = { x: player.x, y: player.y };

    while (!(step.x === minotaur.x && step.y === minotaur.y)) {
        path.push(step);
        step = parent[step.y][step.x];
    }

    path.reverse();
    return path;
}

function updateMinotaurMovement() {

    if (!minotaurVisible) return;
    if (!minotaurActive) return;

    const now = performance.now();

    if (now - minotaurLastMoveTime < MINOTAUR_MOVE_DELAY) return;

    minotaurLastMoveTime = now;

    // If no path or player moved, recompute
    if (
        minotaurPath.length === 0 ||
        minotaurPath[minotaurPath.length - 1].x !== player.x ||
        minotaurPath[minotaurPath.length - 1].y !== player.y
    ) {
        minotaurPath = computeMinotaurPath();
    }

    if (minotaurPath.length > 0) {
        const nextStep = minotaurPath.shift();
        minotaur.x = nextStep.x;
        minotaur.y = nextStep.y;
    }
}

function checkMinotaurCollision() {
    if (!minotaurActive) return;

    if (
        player.x === minotaur.x &&
        player.y === minotaur.y
    ) {
        minotaurActive = false;
	minotaurSpeak("eat.. eat");
        showDefeatMessage();
        draw2D();
    }
}

function checkMinotaurVision() {
    if (!minotaurActive) return;
    if (player.defeated || player.escaped) return;
    if (minotaurHasSeenPlayer) return;

    if (hasLineOfSight()) {
        minotaurHasSeenPlayer = true;
        minotaurSpeak("food");
    }
}

function minotaurSpeak(text) {
    if (!selectedVoice) return;

    const utterance = new SpeechSynthesisUtterance(text);
    utterance.voice = selectedVoice;
    utterance.pitch = 0.1;   // slightly deeper
    utterance.rate = 0.5;    // slightly slower
    utterance.volume = 1.0;

    speechSynthesis.speak(utterance);
}

function hasLineOfSight() {
    if (!minotaurVisible) return false;

    // Start at minotaur center
    const startX = minotaur.x + 0.5;
    const startY = minotaur.y + 0.5;

    // Target is player center
    const targetX = player.x + 0.5;
    const targetY = player.y + 0.5;

    const dx = targetX - startX;
    const dy = targetY - startY;

    const angle = Math.atan2(dy, dx);

    const sin = Math.sin(angle);
    const cos = Math.cos(angle);

    let prevX = startX;
    let prevY = startY;

    // Distance between them
    const maxDist = Math.sqrt(dx * dx + dy * dy);

    for (let t = 0; t < maxDist; t += 0.02) {

        const x = startX + cos * t;
        const y = startY + sin * t;

        const cx = Math.floor(x);
        const cy = Math.floor(y);

        // Out of bounds = blocked
        if (cx < 0 || cy < 0 || cx >= SIZE || cy >= SIZE) {
            return false;
        }

        const cell = maze[cy][cx];

        // EXACT same wall detection as castRay
        if (
            (cell.walls[0] && y < cy + 0.01) ||
            (cell.walls[2] && y > cy + 0.99) ||
            (cell.walls[3] && x < cx + 0.01) ||
            (cell.walls[1] && x > cx + 0.99)
        ) {
            return false;
        }

        // If we've entered the player's cell → visible
        if (cx === player.x && cy === player.y) {
            return true;
        }

        prevX = x;
        prevY = y;
    }

    return false;
}

/* ============================
   RAYCASTING
   ============================ */
function castRay(angle) {
    const sin = Math.sin(angle);
    const cos = Math.cos(angle);
    let prevX = player.x + 0.5;
    let prevY = player.y + 0.5;

    for (let t = 0; t < 20; t += 0.02) {
        const x = player.x + 0.5 + cos * t;
        const y = player.y + 0.5 + sin * t;
        const cx = Math.floor(x);
        const cy = Math.floor(y);

        if (cx < 0 || cy < 0 || cx >= SIZE || cy >= SIZE) {
            let wall;
            if (cx < 0) wall = 3;
            else if (cx >= SIZE) wall = 1;
            else if (cy < 0) wall = 0;
            else wall = 2;
            return { dist:t, cellX:Math.floor(prevX), cellY:Math.floor(prevY), wall };
        }

        const cell = maze[cy][cx];
        if (
            (cell.walls[0] && y < cy + 0.01) ||
            (cell.walls[2] && y > cy + 0.99) ||
            (cell.walls[3] && x < cx + 0.01) ||
            (cell.walls[1] && x > cx + 0.99)
        ) {
            return {
                dist:t,
                cellX:cx,
                cellY:cy,
                wall:(y<cy+0.01?0:y>cy+0.99?2:x<cx+0.01?3:1)
            };
        }

        seen[cy][cx] = true;
        prevX = x;
        prevY = y;
    }
    return { dist:20, cellX:0, cellY:0, wall:0 };
}

/* ============================
   DRAWING
   ============================ */
function draw3D() {
    ctx3.fillStyle = "#4fc3f7";
    ctx3.fillRect(0, 0, 400, 200);
    ctx3.fillStyle = "#2e7d32";
    ctx3.fillRect(0, 200, 400, 200);

    const baseAngle = player.dir * Math.PI / 2 - Math.PI / 2;

    for (let i = 0; i < RAYS; i++) {
        const angle = baseAngle + (i/RAYS - 0.5) * FOV;
        const hit = castRay(angle);
        const dist = Math.max(hit.dist, 0.0001);
        const h = 300 / dist;

        const light = Math.max(0, 1 - dist / MAX_LIGHT_DIST);
        const c = wallColors[hit.cellY][hit.cellX][hit.wall];

        ctx3.fillStyle = `rgb(${(c.r*light)|0},${(c.g*light)|0},${(c.b*light)|0})`;
        ctx3.fillRect(i*2, 200 - h/2, 2, h);
    } 
    drawMinotaur3D();
}

function drawMinotaur3D() {
    if (!minotaurVisible) return;

    // Minotaur world position (center of cell)
    const mx = minotaur.x + 0.5;
    const my = minotaur.y + 0.5;

    // Player world position (center)
    const px = player.x + 0.5;
    const py = player.y + 0.5;

    const dx = mx - px;
    const dy = my - py;

    const rawDistance = Math.sqrt(dx * dx + dy * dy);

    // Compute angle from player to minotaur
    const angleToMinotaur = Math.atan2(dy, dx);

    // Player view direction
    const playerAngle = player.dir * Math.PI / 2 - Math.PI / 2;

    // Angle difference
    let angleDiff = angleToMinotaur - playerAngle;

    // Correct for fisheye
    const distance = rawDistance * Math.cos(angleDiff);

    // Normalize angle to [-PI, PI]
    while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
    while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;

    // If outside FOV, do not draw
    if (Math.abs(angleDiff) > FOV / 2) return;

    // Convert angle to screen X
    const screenX = (0.5 + angleDiff / FOV) * 400;

    // ----------------------------
    // SIZE CALCULATION
    // ----------------------------

    // Wall height reference:
    // h = 300 / dist
    // That represents 10 feet tall.

    const wallHeight = 300 / distance;

    // Minotaur is 8 ft tall, so scale proportionally
    const spriteHeight = wallHeight * (8 / 10);

    const spriteWidth = spriteHeight * (minotaurImg.width / minotaurImg.height);

    // Compute projected ground position
    const horizonY = 200; // screenHeight / 2

    const groundY = horizonY + wallHeight / 2;

    // Feet should touch ground
    const screenY = groundY - spriteHeight;

    ctx3.drawImage(
        minotaurImg,
        screenX - spriteWidth / 2,
        screenY,
        spriteWidth,
        spriteHeight
    );
}

function draw2D() {
    ctx2.fillStyle = "#2e7d32";
    ctx2.fillRect(0,0,400,400);
    ctx2.strokeStyle = "#b71c1c";
    ctx2.lineWidth = 2;

    for (let y=0;y<SIZE;y++) for (let x=0;x<SIZE;x++) {
        const px=x*CELL, py=y*CELL;
        if (!seen[y][x]) {
            ctx2.fillStyle = "#555";
            ctx2.fillRect(px,py,CELL,CELL);
            continue;
        }
        const w = maze[y][x].walls;
        if (x===SIZE-1 && y===SIZE-1) {
            if (w[0]) ctx2.beginPath(),ctx2.moveTo(px,py),ctx2.lineTo(px+CELL,py),ctx2.stroke();
            if (w[3]) ctx2.beginPath(),ctx2.moveTo(px,py),ctx2.lineTo(px,py+CELL),ctx2.stroke();
            continue;
        }
        if (w[0]) ctx2.beginPath(),ctx2.moveTo(px,py),ctx2.lineTo(px+CELL,py),ctx2.stroke();
        if (w[1]) ctx2.beginPath(),ctx2.moveTo(px+CELL,py),ctx2.lineTo(px+CELL,py+CELL),ctx2.stroke();
        if (w[2]) ctx2.beginPath(),ctx2.moveTo(px,py+CELL),ctx2.lineTo(px+CELL,py+CELL),ctx2.stroke();
        if (w[3]) ctx2.beginPath(),ctx2.moveTo(px,py),ctx2.lineTo(px,py+CELL),ctx2.stroke();
    }

    if (!player.escaped) {
        ctx2.save();
        ctx2.translate(player.x*CELL + CELL/2, player.y*CELL + CELL/2);
        ctx2.rotate(player.dir * Math.PI/2 - Math.PI/2);
        ctx2.fillStyle = "#aaa";

        const tip = CELL * 0.4;
        const wing = CELL * 0.3;

        ctx2.beginPath();
        ctx2.moveTo(tip, 0);
        ctx2.lineTo(-wing, wing);
        ctx2.lineTo(-wing, -wing);
        ctx2.fill();

        ctx2.restore();
    }
    if (minotaurVisible) {
        drawMinotaur2D();
    }
}

function drawMinotaur2D() {
    const cx = minotaur.x * CELL + CELL / 2;
    const cy = minotaur.y * CELL + CELL / 2;

    const headRadius = CELL * 0.22;   // similar to original strong head
    const hornLength = CELL * 0.18;   // horizontal part
    const hornThickness = CELL * 0.10;
    const hornTipHeight = CELL * 0.30;


    const snoutWidth = CELL * 0.32;
    const snoutHeight = CELL * 0.20;

    ctx2.save();
    ctx2.translate(cx, cy);
    ctx2.fillStyle = "#888";

    /*
        LEFT HORN - RECTANGLE
    */
    ctx2.fillRect(
        -headRadius - hornLength,
        -hornThickness / 2,
        hornLength,
        hornThickness
    );

    /*
        LEFT HORN - TRIANGLE (pointing up)
    */
    ctx2.beginPath();
    ctx2.moveTo(-headRadius - hornLength, -hornThickness / 2);
    ctx2.lineTo(-headRadius - hornLength, -hornTipHeight);
    ctx2.lineTo(-headRadius - hornLength + hornThickness, -hornThickness / 2);
    ctx2.closePath();
    ctx2.fill();

    /*
        RIGHT HORN - RECTANGLE
    */
    ctx2.fillRect(
        headRadius,
        -hornThickness / 2,
        hornLength,
        hornThickness
    );

    /*
        RIGHT HORN - TRIANGLE (pointing up)
    */
    ctx2.beginPath();
    ctx2.moveTo(headRadius + hornLength, -hornThickness / 2);
    ctx2.lineTo(headRadius + hornLength, -hornTipHeight);
    ctx2.lineTo(headRadius + hornLength - hornThickness, -hornThickness / 2);
    ctx2.closePath();
    ctx2.fill();

    /*
        HEAD (stronger presence)
    */
    ctx2.beginPath();
    ctx2.arc(0, 0, headRadius, 0, Math.PI * 2);
    ctx2.fill();

    /*
        SNOUT
    */
    ctx2.fillRect(
        -snoutWidth / 2,
        headRadius * 0.3,
        snoutWidth,
        snoutHeight
    );

    ctx2.restore();
}

function showDefeatMessage() {
    statusEl.textContent = "You are defeated.";
    player.defeated = true;
    resetBtn.disabled=false;
    resetBtn.style.display = "block";
    // This is a bit of a quirk to resart at level 0. TODO: look into this
    levelIndex = 4;
}

/* ============================
   INPUT / LOOP
   ============================ */
document.addEventListener("keydown", e => {
    if (player.escaped) return;
    if (player.defeated) return;
    if (e.key==="ArrowLeft") player.dir = (player.dir+3)%4;
    if (e.key==="ArrowRight") player.dir = (player.dir+1)%4;
    if (e.key==="ArrowUp") {
        const dx=[0,1,0,-1][player.dir];
        const dy=[-1,0,1,0][player.dir];
        if (!maze[player.y][player.x].walls[player.dir]) {
            player.x+=dx; 
            player.y+=dy;

            if (!minotaurTimerStarted && (player.x !== 0 || player.y !== 0)) {
                minotaurTimerStarted = true;
                minotaurStartTime = performance.now();
            }

            if (player.x===SIZE-1 && player.y===SIZE-1) {
                player.escaped=true;
    		minotaurActive = false;
                if (levelIndex < SIZE_OPTIONS.length - 1) {
                    statusEl.textContent = "You Escaped!"; 
                } else {
                    statusEl.textContent = "You Win!"
                }
                resetBtn.disabled=false;
    		resetBtn.style.display = "block";
            }
        }
    }
});

resetBtn.addEventListener("click", advanceLevel);

speechSynthesis.onvoiceschanged = function() {
    selectMinotaurVoice();
};

function loop() {
    updateMinotaurTimer();
    // updateMinotaurMovement(); // TEMP removal for 3D changes
    checkMinotaurVision();
    checkMinotaurCollision();
    draw3D();
    draw2D();
    requestAnimationFrame(loop);
}

initGame();
loop();
</script>
</body>
</html>
