<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Maze</title>
<style>
body {
    margin: 0;
    background: black;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    height: 100vh;
}

#container {
    display: flex;
    gap: 16px;
}
canvas {
    border: 2px solid #444;
}
#statusRow {
    width: 816px;
    position: relative;
    margin-top: 12px;
}

#status {
    color: white;
    font-size: 18px;
    text-align: center;
    height: 24px;
    line-height: 24px;
}

.ui-button {
    position: absolute;
    right: 0;
    top: 0;
    font-size: 14px;
    padding: 6px 12px;
}

#topRow {
    color: #c9c3b5;
    font-family: "Cinzel", serif;
    font-size: 42px;
    letter-spacing: 6px;
    text-align: center;
    margin-bottom: 4px;
    text-shadow: 2px 2px 6px black;
}


</style>
</head>
<body>

<div id="topRow">
    <div id="title">MINOTAUR</div>
</div>
<div id="container">
    <canvas id="view3d" width="400" height="400"></canvas>
    <canvas id="view2d" width="400" height="400"></canvas>
</div>
<div id="statusRow">
    <div id="status"></div>
    <button id="resetBtn" class="ui-button" disabled style="display:none;">Reset Maze</button>
</div>

<script>
let SIZE;
let CELL;
const FOV = Math.PI / 3;
const RAYS = 200;
const DEFAULT_WALL_COLOR = { r:180, g:30, b:30 };
const MAX_LIGHT_DIST = 12;
const SIZE_OPTIONS = [8, 10, 16, 20, 25];
const CELL_OPTIONS = [50, 40, 25, 20, 16];
let levelIndex = 0;
SIZE = SIZE_OPTIONS[levelIndex];
CELL = CELL_OPTIONS[levelIndex];

// Core state (allocated once)
const maze = [];
const wallColors = [];
const seen = [];

const player = {
    x: 0,
    y: 0,
    dir: 1,
    escaped: false
};

// Contexts
const ctx3 = view3d.getContext("2d");
const ctx2 = view2d.getContext("2d");
const statusEl = document.getElementById("status");
const resetBtn = document.getElementById("resetBtn");

// DFS maze generation
function dfs(x, y) {
    maze[y][x].visited = true;
    for (let d of [0,1,2,3].sort(()=>Math.random()-0.5)) {
        const nx = x + [0,1,0,-1][d];
        const ny = y + [-1,0,1,0][d];
        if (nx>=0 && ny>=0 && nx<SIZE && ny<SIZE && !maze[ny][nx].visited) {
            maze[y][x].walls[d] = 0;
            maze[ny][nx].walls[(d+2)%4] = 0;
            dfs(nx, ny);
        }
    }
}

/* ============================
   INIT / RESET GAME
   ============================ */
function initGame() {
    // Build maze + wall colors
    for (let y = 0; y < SIZE; y++) {
        maze[y] = [];
        wallColors[y] = [];
        seen[y] = [];
        for (let x = 0; x < SIZE; x++) {
            maze[y][x] = { visited:false, walls:[1,1,1,1] };
            wallColors[y][x] = [
                { ...DEFAULT_WALL_COLOR },
                { ...DEFAULT_WALL_COLOR },
                { ...DEFAULT_WALL_COLOR },
                { ...DEFAULT_WALL_COLOR }
            ];
            seen[y][x] = false;
        }
    }

    // Generate maze
    dfs(0, 0);

    // Exit walls (lower-right)
    wallColors[SIZE-1][SIZE-1][1] = { r:0, g:180, b:0 };
    wallColors[SIZE-1][SIZE-1][2] = { r:0, g:180, b:0 };

    // Reset player
    player.x = 0;
    player.y = 0;
    player.dir = 1;
    player.escaped = false;

    // UI reset
    statusEl.textContent = "";
    resetBtn.disabled = true;
    resetBtn.style.display = "none";
}

function advanceLevel() {
    if (levelIndex < SIZE_OPTIONS.length - 1) {
        levelIndex++;
    } else {
        levelIndex = 0;
    }

    sizeIndex = levelIndex;
    SIZE = SIZE_OPTIONS[sizeIndex];
    CELL = CELL_OPTIONS[sizeIndex];

    initGame();
}

/* ============================
   RAYCASTING
   ============================ */
function castRay(angle) {
    const sin = Math.sin(angle);
    const cos = Math.cos(angle);
    let prevX = player.x + 0.5;
    let prevY = player.y + 0.5;

    for (let t = 0; t < 20; t += 0.02) {
        const x = player.x + 0.5 + cos * t;
        const y = player.y + 0.5 + sin * t;
        const cx = Math.floor(x);
        const cy = Math.floor(y);

        if (cx < 0 || cy < 0 || cx >= SIZE || cy >= SIZE) {
            let wall;
            if (cx < 0) wall = 3;
            else if (cx >= SIZE) wall = 1;
            else if (cy < 0) wall = 0;
            else wall = 2;
            return { dist:t, cellX:Math.floor(prevX), cellY:Math.floor(prevY), wall };
        }

        const cell = maze[cy][cx];
        if (
            (cell.walls[0] && y < cy + 0.01) ||
            (cell.walls[2] && y > cy + 0.99) ||
            (cell.walls[3] && x < cx + 0.01) ||
            (cell.walls[1] && x > cx + 0.99)
        ) {
            return {
                dist:t,
                cellX:cx,
                cellY:cy,
                wall:(y<cy+0.01?0:y>cy+0.99?2:x<cx+0.01?3:1)
            };
        }

        seen[cy][cx] = true;
        prevX = x;
        prevY = y;
    }
    return { dist:20, cellX:0, cellY:0, wall:0 };
}

/* ============================
   DRAWING
   ============================ */
function draw3D() {
    ctx3.fillStyle = "#4fc3f7";
    ctx3.fillRect(0, 0, 400, 200);
    ctx3.fillStyle = "#2e7d32";
    ctx3.fillRect(0, 200, 400, 200);

    const baseAngle = player.dir * Math.PI / 2 - Math.PI / 2;

    for (let i = 0; i < RAYS; i++) {
        const angle = baseAngle + (i/RAYS - 0.5) * FOV;
        const hit = castRay(angle);
        const dist = Math.max(hit.dist, 0.0001);
        const h = 300 / dist;

        const light = Math.max(0, 1 - dist / MAX_LIGHT_DIST);
        const c = wallColors[hit.cellY][hit.cellX][hit.wall];

        ctx3.fillStyle = `rgb(${(c.r*light)|0},${(c.g*light)|0},${(c.b*light)|0})`;
        ctx3.fillRect(i*2, 200 - h/2, 2, h);
    }
}

function draw2D() {
    ctx2.fillStyle = "#2e7d32";
    ctx2.fillRect(0,0,400,400);
    ctx2.strokeStyle = "#b71c1c";
    ctx2.lineWidth = 2;

    for (let y=0;y<SIZE;y++) for (let x=0;x<SIZE;x++) {
        const px=x*CELL, py=y*CELL;
        if (!seen[y][x]) {
            ctx2.fillStyle = "#555";
            ctx2.fillRect(px,py,CELL,CELL);
            continue;
        }
        const w = maze[y][x].walls;
        if (x===SIZE-1 && y===SIZE-1) {
            if (w[0]) ctx2.beginPath(),ctx2.moveTo(px,py),ctx2.lineTo(px+CELL,py),ctx2.stroke();
            if (w[3]) ctx2.beginPath(),ctx2.moveTo(px,py),ctx2.lineTo(px,py+CELL),ctx2.stroke();
            continue;
        }
        if (w[0]) ctx2.beginPath(),ctx2.moveTo(px,py),ctx2.lineTo(px+CELL,py),ctx2.stroke();
        if (w[1]) ctx2.beginPath(),ctx2.moveTo(px+CELL,py),ctx2.lineTo(px+CELL,py+CELL),ctx2.stroke();
        if (w[2]) ctx2.beginPath(),ctx2.moveTo(px,py+CELL),ctx2.lineTo(px+CELL,py+CELL),ctx2.stroke();
        if (w[3]) ctx2.beginPath(),ctx2.moveTo(px,py),ctx2.lineTo(px,py+CELL),ctx2.stroke();
    }

    if (!player.escaped) {
        ctx2.save();
        ctx2.translate(player.x*CELL+CELL/2, player.y*CELL+CELL/2);
        ctx2.rotate(player.dir*Math.PI/2 - Math.PI/2);
        ctx2.fillStyle = "#aaa";
        ctx2.beginPath();
        ctx2.moveTo(8,0);
        ctx2.lineTo(-6,6);
        ctx2.lineTo(-6,-6);
        ctx2.fill();
        ctx2.restore();
    }
}

/* ============================
   INPUT / LOOP
   ============================ */
document.addEventListener("keydown", e => {
    if (player.escaped) return;
    if (e.key==="ArrowLeft") player.dir = (player.dir+3)%4;
    if (e.key==="ArrowRight") player.dir = (player.dir+1)%4;
    if (e.key==="ArrowUp") {
        const dx=[0,1,0,-1][player.dir];
        const dy=[-1,0,1,0][player.dir];
        if (!maze[player.y][player.x].walls[player.dir]) {
            player.x+=dx; player.y+=dy;
            if (player.x===SIZE-1 && player.y===SIZE-1) {
                player.escaped=true;
                if (levelIndex < SIZE_OPTIONS.length - 1) {
                    statusEl.textContent = "You Escaped!"; 
                } else {
                    statusEl.textContent = "You Win!"
                }
                resetBtn.disabled=false;
    		resetBtn.style.display = "block";
            }
        }
    }
});

resetBtn.addEventListener("click", advanceLevel);

function loop() {
    draw3D();
    draw2D();
    requestAnimationFrame(loop);
}

initGame();
loop();
</script>
</body>
</html>
